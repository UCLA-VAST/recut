#include <cstdio>

/*
 * This file is copied directly from the vaa3d_tools github repository as part of the following works:
 *
Peng, H., Ruan, Z., Long, F., Simpson, J.H., and Myers, E.W. (2010) “V3D enables real-time 3D visualization and quantitative analysis of large-scale biological image data sets,” Nature Biotechnology, Vol. 28, No. 4, pp. 348-353, DOI: 10.1038/nbt.1612. ( http://penglab.janelia.org/papersall/docpdf/2010_NBT_V3D.pdf )

Peng, H, Ruan, Z., Atasoy, D., and Sternson, S. (2010) “Automatic reconstruction of 3D neuron structures using a graph-augmented deformable model,” Bioinformatics, Vol. 26, pp. i38-i46, 2010. ( http://penglab.janelia.org/papersall/docpdf/2010_Bioinfo_GD_ISMB2010.pdf )
*/ 

char checkMachineEndian()
{
    char e='N'; //for unknown endianness

    long long int a=0x44332211;
    unsigned char * p = (unsigned char *)&a;
    if ((*p==0x11) && (*(p+1)==0x22) && (*(p+2)==0x33) && (*(p+3)==0x44))
        e = 'L';
    else if ((*p==0x44) && (*(p+1)==0x33) && (*(p+2)==0x22) && (*(p+3)==0x11))
        e = 'B';
    else if ((*p==0x22) && (*(p+1)==0x11) && (*(p+2)==0x44) && (*(p+3)==0x33))
        e = 'M';
    else
        e = 'N';

    return e;
}


void swap2bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+1);
    *(tp+1) = a;
}

void swap4bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+3);
    *(tp+3) = a;
    a = *(tp+1);
    *(tp+1) = *(tp+2);
    *(tp+2) = a;
}

int loadRaw2Stack_2byte(char * filename, unsigned char * & img, long long * & sz, int & datatype)
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	long long fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	long long nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	long long i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	auto code = fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	code = fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}

	long long unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	code = fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	if (sz) {delete []sz; sz=0;}
	sz = new long long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	long long totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (long long)mysz[i];
		totalUnit *= sz[i];
	}

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		//printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		//printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}

